# Debugging the DDlog version of ovn-northd

This document gives some tips for debugging correctness issues in the DDlog
implementation of `ovn-northd`.  To keep things conrete, we assume
here that a failure occurred in one of the test cases in `ovn-e2e.at`, but the same
methodology applies in any other environment.

We consider several debugging techniques.  The first one only looks at the output
of the DDlog program, while the other two allow inspecting internal DDlog tables:

1. Compare OVSDB tables generated by DDlog vs C
1. Dump DDlog tables at runtime
1. Debug with "printfs"
1. Record and replay DDlog execution

If none of the above methods helps,
[complain to DDlog developers](#submitting-a-bug-report).

Before trying these methods, you may want to check the northd log file,
`tests/testsuite.dir/<test_number>/northd/ovn-northd.log` for error messages that
might explain the failure.

## Compare OVSDB tables generated by DDlog vs C

The first thing I typically want to check when `ovn-northd-ddlog` does not behave
as expected is how the OVSDB tables computed by DDlog differ from what the C
implementation produces.  Fortunately, all the infrastructure needed to do this
already exists in OVN.  First, let's modify the test script, e.g., `ovn-e2e.at` to
dump the contents of OVSDB right before the failure.  The following code dumps
router-related NB and SB tables, as well as all logical flows.

```
echo "---------NB dump-----"
ovn-nbctl show
echo "---------------------"
ovn-nbctl list logical_router
echo "---------------------"
ovn-nbctl list logical_router_port
echo "---------------------"

echo "---------SB dump-----"
ovn-sbctl list datapath_binding
echo "---------------------"
ovn-sbctl list port_binding
echo "---------------------"
ovn-sbctl dump-flows
```

Next, we want to run the test twice, with the C and DDlog versions of northd,
e.g., `make check -j6 TESTSUITEFLAGS="2707 2780"`, where 2707 and
2780 are respectively C and DDlog versions of the same test.  There is a slight
hiccup here: the C version of the test may succeed and automatically remove all
of its working files.  To prevent this, I insert the following autotest command
to force the test to fail write after dumping OVSDB state.

```
AT_FAIL_IF([:])
```

You should end up with two `testsuite.log` files that both contain OVSDB
dumps towards the end.  You can compare these dumps to see how the output
computed by DDlog differs from C.  The DDlog output should be identical to C,
except in the following three ways:

- UUID's are assigned automatically by OVSDB and will differ across test runs.

- Since OVSDB dumps records sorted by UUIDs (I think?) the order in which records
  are dumped will differ across test runs.

- DDlog uses a different algorithm to allocate tunnel IDs or VLAN tags and port
  numbers; as a result their value will differ between C and DDlog dumps.

Unfortunately, because of these differences, comparing the two dumps is not just
a matter of running `diff`.  It is currently a manual process that is tedious
even for tiny networks.  It should be relatively straightforward to automate
this task, but we haven't had a chance to do this yet.

Often, once you have identified the difference between the two OVSDB dumps, this
will immediately lead you to the root cause of the bug, but if you are not this
lucky then the next method may help.

## Dump DDlog tables at runtime

Oftentimes, you will find that OVSDB tables generated by `ovn-northd-ddlog`
contain incorrect records (or do not contain the records you expected), but you
won't be able to tell what went wrong by just staring at the code.  In other
words, your mental model of the DDlog code suggests that the output should look
different from what you observe in OVSDB.  In cases like this, the next step is
to dump some of the intermediate DDlog relations that are responsible for the
missing or incorrect output records.

To do so, add the following line to the `ddlog_debug_dump()` function in
`ovn-northd-ddlog.c` for each relation you would like to dump:

```
ddlog_table_debug_dump(ddlog, "lswitch.SwitchPortIPv4Address");
```

replacing `lswitch.SwitchPortIPv4Address` with the fully qualified name of the relation
(in the `<module_name>.<relation_name>` format).

In addition, since DDlog only allows dumping output relations, you have to modify the
DDlog relation declaration to label the relation as an output, e.g.:

```
output /*added for debugging*/
relation SwitchPortIPv4Address(port: Ref<SwitchPort>,
                               ea_s:   string,
                               addr:   ipv4_netaddr)
```

When you run the test again with these changes, DDlog will dump the contents of the
relations you requested to `ovn-northd.log` after each transaction.  In most cases,
this provides sufficient forensic evidence to nail down the issue.

## Debugging with "printfs"

One limitation of the previous method is that it allows one to inspect inputs and outputs
of a rule, but not the (sometimes fairly complicated) computation that goes on inside the
rule.  You can of course break up the rule into several rules and dump the intermediate
outputs.  Another alternative is to print values of one or more variables from inside the
rule using the `warn()` function declared in `ovn.dl`.  This is not as straightforward
as printf-based debugging in imperative languages like C, since DDlog is a declarative
language where the user doesn't directly control when various rules are triggered.  In
particular, you might see the rule being triggered multiple times with the same input.
Nevertheless, this debuggin technique is often useful in practice.

You will find many examples of the use of the `warn` function in `ovn_northd.dl`, where it
is frequently used to report non-critical errors.

## Record and replay DDlog execution

DDlog offers a way to record all input table updates throughout the execution of
northd and replay them against DDlog running as a standalone executable without
all other OVN components.  This has two advantages.  First, this allows one to
easily tweak the inputs, e.g., to simplify the test scenario.  Second, the
recorded execution can be easily replayed anywhere without having to reproduce
your OVN setup.

To enable recording, simply uncomment the following line in
`ovn-northd-ddlog.c`:

```
//#define DDLOG_RECORDING
```

DDlog should now create a `replay.dat` file, which contains the log of transactions
in the DDlog command format documented
[here](https://github.com/vmware/differential-datalog/blob/master/doc/testing/testing.md#command-reference).

To replay the log, you will need the standalone DDlog executable.  The build
system is setup to not compile this program by default, as it nearly doubles
the, already annoyingly long, Rust compilation time.  To enable the generation
of this standalone DDlog executable, re-run the `configure` script with the
`--enable-ddlog-northd-cli` option.  When then run `make`, it will generate the
folloging executable: `ovn/northd/ovn_northd_ddlog/target/release/ovn_northd_cli`.

You can modify the log before replaying it, e.g., adding `dump <table>` commands to
dump the contents of relations at various points during execution.

The following command replays the log generated by OVN test number 2709 and dumps
the output of DDlog to `replay.dump`.

```
ovn/northd/ovn_northd_ddlog/target/release/ovn_northd_cli -w 1 --no-print < tests/testsuite.dir/2709/northd/replay.dat > replay.dump
```

## Submitting a bug report

If you are having trouble with DDlog and the above methods do not help, please submit a bug report to
`bugs@openvswitch.org`, CC `ryzhyk@gmail.com`.

In addition to problem description, please provide as many of the following as possible:

- Are you running with the latest DDlog (from the `master` branch of the DDlog
  repository) and northd (from the `ddlog-dev` branch of the
  [https://github.com/ovn-org/ovn](https://github.com/ovn-org/ovn) repo)?  If not,
  what commits of either are you on?

- `replay.dat` file generated as described above

- Logs: `ovn-northd.log` and `testsuite.log`, if you are running the OVN test suite
